#include <cftal/vec_cvt.h>
#include <cftal/math/elem_func.h>
#include <cftal/math/elem_func_core_f32.h>
#include <cftal/d_real.h>
#include <ocl/test/ops_base.h>
#include "ocl/dvec.h"
// #include <vexcl/vexcl.hpp>
#include <chrono>
#include <thread>
#include <limits>


/*
You can dump the list of kernels and the LLVM IR when a program runs by
doing the following:
CLOVER_DEBUG_FILE=clover_dump CLOVER_DEBUG=clc,llvm,asm
PATH_TO_YOUR_TEST_PROGRAM
--> use native instead of asm

That'll generate a set of files called clover_dump.cl, clover_dump.ll,
clover_dump.asm with:
a) The CL source that the program tried to compile
b) The LLVM IR for the CL source.
c) The generated machine code for the LLVM IR on your card.

If the CL source is missing built-in function implementations, libclc (
libclc.llvm.org) will gladly accept patches to implement them.

If you want to just do a test-compile of the CL source, I use the following
command (with libclc/llvm/mesa all in /usr/local/):
clang -S -emit-llvm -o $1.ll -include /usr/local/include/clc/clc.h
-I/usr/local/include/ -Dcl_clang_storage_class_specifiers -target amdgcn--
-mcpu=pitcairn -c $1
*/


namespace ocl {
    
    namespace impl {

        template <typename _T, typename _C, size_t _N, size_t _I>
        struct unroll_horner {
            template <typename _E>
            static
            auto
            v(_T x, _E e, const _C* p) {
                using v_t = unroll_horner<_T, _C, _N, _I-1>;
                return v_t::v(x, x*e + p[_N-_I], p);
            }
        };

        template <typename _T, typename _C, size_t _N>
        struct unroll_horner<_T, _C, _N, 1> {
            template <typename _E>
            static
            auto
            v(_T x, _E e, const _C* p) {
                return x*e + p[_N-1];
            }
        };
        
    }

    namespace test {

        class horner_f32 : public ops_base<float> {
            using b_t = ops_base<float>;
            using b_t::_res;
            using b_t::_a0;
            using b_t::_a1;
            using b_t::_h_res;
            using b_t::_h_a0;
            using b_t::_h_a1;
            using b_t::check_res;

            // coefficients for exp generated by sollya
            // x^0 : +0x8p-3
            static
            constexpr
            const double exp_c0=+1.0000000000000000000000e+00;
            // x^1 : +0x8p-3
            static
            constexpr
            const double exp_c1=+1.0000000000000000000000e+00;
            // x^2 : +0x8p-4
            static
            constexpr
            const double exp_c2=+5.0000000000000000000000e-01;
            // x^3 : +0xa.aaaaaaaaaaaa8p-6
            static
            constexpr
            const double exp_c3=+1.6666666666666665741481e-01;
            // x^4 : +0xa.aaaaaaaaaaacp-8
            static
            constexpr
            const double exp_c4=+4.1666666666666685170384e-02;
            // x^5 : +0x8.888888888961p-10
            static
            constexpr
            const double exp_c5=+8.3333333333340843529502e-03;
            // x^6 : +0xb.60b60b60a81p-13
            static
            constexpr
            const double exp_c6=+1.3888888888873365812238e-03;
            // x^7 : +0xd.00d00cfa88cc8p-16
            static
            constexpr
            const double exp_c7=+1.9841269839039331096715e-04;
            // x^8 : +0xd.00d00d6b5b978p-19
            static
            constexpr
            const double exp_c8=+2.4801587348902822885563e-05;
            // x^9 : +0xb.8ef1e87f81768p-22
            static
            constexpr
            const double exp_c9=+2.7557322326013774747291e-06;
            // x^10 : +0x9.3f26623e02258p-25
            static
            constexpr
            const double exp_c10=+2.7557252167692825528943e-07;
            // x^11 : +0xd.72da4d99dd1ep-29
            static
            constexpr
            const double exp_c11=+2.5050050656120229688701e-08;
            // x^12 : +0x8.fc5bcb2f9dd7p-32
            static
            constexpr
            const double exp_c12=+2.0921639307947297714762e-09;
            // x^13 : +0xb.675e3aadcbc88p-36
            static
            constexpr
            const double exp_c13=+1.6594686274338619941159e-10;
        
            static
            const float coeff4[4];

            static
            const float coeff5[5];

            static
            const float coeff6[6];

            static
            const float coeff7[7];

            static
            const float coeff8[8];

            static
            const float coeff9[9];

            static
            const float coeff10[10];

            static
            const float coeff11[11];

            static
            const float coeff12[12];
            
            static
            const float coeff13[13];

            static
            const float coeff14[14];

        public:
            horner_f32(size_t n)
                : b_t(n, float(-M_LN2/2), float(2*M_LN2/2)) {}
            bool perform();
        };
        
    }

};

const float
ocl::test::horner_f32::coeff4[4]= {
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff5[5]= {
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff6[6]= {
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff7[7]= {
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff8[8]= {
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff9[9]= {
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff10[10]= {
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff11[11]= {
    exp_c10,
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff12[12]= {
    exp_c11,
    exp_c10,
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff13[13]= {
    exp_c12,
    exp_c11,
    exp_c10,
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff14[14]= {
    exp_c13,
    exp_c12,
    exp_c11,
    exp_c10,
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

bool
ocl::test::horner_f32::perform()
{
    using cftal::math::horner;
    using cftal::math::horner2;
    using cftal::math::horner4;
    bool rc=true;

    dvec<float> x2=_a0*_a0;
    dvec<float> x4=x2*x2;
    vsvec<float> h_x2=_h_a0 * _h_a0;
    vsvec<float> h_x4=h_x2 * h_x2;

    constexpr const auto max_rel_tol=0x1p-24f*2.0f; 
    // std::numeric_limits<float>::epsilon();
    
    _res = horner(_a0, coeff4);
    _h_res = horner(_h_a0, coeff4);
    rc &= check_res("horner(v, c[4])", max_rel_tol);

    _res = horner2(_a0, x2, coeff4);
    rc &= check_res("horner2(v, c[4])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff4);
    rc &= check_res("horner4(v, c[4])", 2*max_rel_tol);
    
    _res = horner(_a0, coeff5);
    _h_res = horner(_h_a0, coeff5);
    rc &= check_res("horner(v, c[5])", max_rel_tol);
    _res = horner2(_a0, x2, coeff5);
    rc &= check_res("horner2(v, c[5])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff5);
    rc &= check_res("horner4(v, c[5])", 2*max_rel_tol);

    _res = horner(_a0, coeff6);
    _h_res = horner(_h_a0, coeff6);
    rc &= check_res("horner(v, c[6])", max_rel_tol);
    _res = horner2(_a0, x2, coeff6);
    rc &= check_res("horner2(v, c[6])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff6);
    rc &= check_res("horner4(v, c[6])", 4*max_rel_tol);

    _res = horner(_a0, coeff7);
    _h_res = horner(_h_a0, coeff7);
    rc &= check_res("horner(v, c[7])", max_rel_tol);
    _res = horner2(_a0, x2, coeff7);
    rc &= check_res("horner2(v, c[7])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff7);
    rc &= check_res("horner4(v, c[7])", 4*max_rel_tol);

    _res = horner(_a0, coeff8);
    _h_res = horner(_h_a0, coeff8);
    rc &= check_res("horner(v, c[8])", max_rel_tol);
    _res = horner2(_a0, x2, coeff8);
    rc &= check_res("horner2(v, c[8])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff8);
    rc &= check_res("horner4(v, c[8])", 4*max_rel_tol);

    _res = horner(_a0, coeff9);
    _h_res = horner(_h_a0, coeff9);
    rc &= check_res("horner(v, c[9])", max_rel_tol);
    _res = horner2(_a0, x2, coeff9);
    rc &= check_res("horner2(v, c[9])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff9);
    rc &= check_res("horner4(v, c[9])", 4*max_rel_tol);

    _res = horner(_a0, coeff10);
    _h_res = horner(_h_a0, coeff10);
    rc &= check_res("horner(v, c[10])", max_rel_tol);
    _res = horner2(_a0, x2, coeff10);
    rc &= check_res("horner2(v, c[10])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff10);
    rc &= check_res("horner4(v, c[10])", 4*max_rel_tol);

    _res = horner(_a0, coeff11);
    _h_res = horner(_h_a0, coeff11);
    rc &= check_res("horner(v, c[11])", max_rel_tol);
    _res = horner2(_a0, x2, coeff11);
    rc &= check_res("horner2(v, c[11])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff11);
    rc &= check_res("horner4(v, c[11])", 4*max_rel_tol);

    _res = horner(_a0, coeff12);
    _h_res = horner(_h_a0, coeff12);
    rc &= check_res("horner(v, c[12])", max_rel_tol);
    _res = horner2(_a0, x2, coeff12);
    rc &= check_res("horner2(v, c[12])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff12);
    rc &= check_res("horner4(v, c[12])", 4*max_rel_tol);
    
    _res = horner(_a0, coeff13);
    _h_res = horner(_h_a0, coeff13);
    rc &= check_res("horner(v, c[13])", max_rel_tol);
    _res = horner2(_a0, x2, coeff13);
    rc &= check_res("horner2(v, c[13])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff13);
    rc &= check_res("horner4(v, c[13])", 4*max_rel_tol);

    _res = horner(_a0, coeff14);
    _h_res = horner(_h_a0, coeff14);
    rc &= check_res("horner(v, c[14])", max_rel_tol);
    _res = horner2(_a0, x2, coeff14);
    rc &= check_res("horner2(v, c[14])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff14);
    rc &= check_res("horner4(v, c[14])", 4*max_rel_tol);

    return rc;
}


int main()
{
    try {
        using namespace cftal;
        using namespace ocl;
        using namespace ocl::test;

        using rtype = float;
        // using itype = int64_t;
        // using v8fXX = cftal::vec<ftype, 8>;
        for (std::size_t i=4; i<16*16384; i <<=1) {
            if (1) {
                std::cout << "using buffers with "
                          <<  i
                          << " elements (" << i*sizeof(rtype)
                          << " bytes)\r" << std::flush;
            }
            horner_f32 t(i);
            if (t.perform() == false) {
                std::cout << "\ntest for vector length " << i << " failed\n";
                std::exit(3);
            }
        }
        std::cout << "\ntest passed\n";
    }
    catch (const ocl::be::error& e) {
        std::cout << "caught exception: " << e.what()
                  << '\n'
                  << e.error_string()
                  << std::endl;
    }
    catch (const std::runtime_error& e) {
        std::cout << "caught exception: " << e.what()
                  << std::endl;
    }
    return 0;
}

