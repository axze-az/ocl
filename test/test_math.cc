#include <cftal/vec_cvt.h>
#include <cftal/math/elem_func.h>
#include <cftal/math/elem_func_core_f32.h>
#include <cftal/d_real.h>
#include <ocl/test/ops_base.h>
#include "ocl/dvec.h"
// #include <vexcl/vexcl.hpp>
#include <chrono>
#include <thread>
#include <limits>


/*
You can dump the list of kernels and the LLVM IR when a program runs by
doing the following:
CLOVER_DEBUG_FILE=clover_dump CLOVER_DEBUG=clc,llvm,asm
PATH_TO_YOUR_TEST_PROGRAM
--> use native instead of asm

That'll generate a set of files called clover_dump.cl, clover_dump.ll,
clover_dump.asm with:
a) The CL source that the program tried to compile
b) The LLVM IR for the CL source.
c) The generated machine code for the LLVM IR on your card.

If the CL source is missing built-in function implementations, libclc (
libclc.llvm.org) will gladly accept patches to implement them.

If you want to just do a test-compile of the CL source, I use the following
command (with libclc/llvm/mesa all in /usr/local/):
clang -S -emit-llvm -o $1.ll -include /usr/local/include/clc/clc.h
-I/usr/local/include/ -Dcl_clang_storage_class_specifiers -target amdgcn--
-mcpu=pitcairn -c $1
*/

namespace cftal {

    template <>
    struct d_real_traits<ocl::dvec<float> > {
        constexpr static const bool fma=true;
        using cmp_result_type = typename ocl::dvec<int32_t>;
        using int_type = ocl::dvec<int32_t>;

        static
        bool any_of_v(const cmp_result_type& b) {
            return true;
        }

        static
        bool all_of_v(const cmp_result_type& b) {
            return false;
        }

        static
        bool none_of_v(const cmp_result_type& b) {
            return false;
        }

        static
        ocl::dvec<float>
        sel (const cmp_result_type& s,
             const ocl::dvec<float>& on_true,
             const ocl::dvec<float>& on_false) {
            // return select(s, on_true, on_false);
            return on_true;
        }

        static
        void
        split(const ocl::dvec<float> & a,
              ocl::dvec<float>& h,
              ocl::dvec<float>& l) {
#if 0
            const int32_t msk=
                const_u32<0xfffff000U>::v.s32();
            using vi_type = ocl::dvec<int32_t>;
            vi_type& hi=reinterpret_cast<vi_type&>(h);
            const vi_type& ai=reinterpret_cast<const vi_type&>(a);
            hi = ai & msk;
            l= a - h;
#else
            const int32_t msk=
                const_u32<0xfffff000U>::v.s32();
            using vi_type = ocl::dvec<int32_t>;
            using vf_type = ocl::dvec<float>;
            using ocl::as;
            h=as<vf_type>(as<vi_type>(a) & msk);
            l=a - h;
#endif
        }

        constexpr
        static
        float
        scale_div_threshold() {
            // -126 + 24
            return 0x1.p-102f;
        }

    };
}

namespace ocl {

    
    namespace impl {

        template <typename _T, typename _C, size_t _N, size_t _I>
        struct unroll_horner {
            template <typename _E>
            static
            auto
            v(_T x, _E e, const _C* p) {
                using v_t = unroll_horner<_T, _C, _N, _I-1>;
                return v_t::v(x, x*e + p[_N-_I], p);
            }
        };

        template <typename _T, typename _C, size_t _N>
        struct unroll_horner<_T, _C, _N, 1> {
            template <typename _E>
            static
            auto
            v(_T x, _E e, const _C* p) {
                return x*e + p[_N-1];
            }
        };
        
    }

    namespace test {

        class horner_f32 : public ops_base<float> {
            using b_t = ops_base<float>;
            using b_t::_res;
            using b_t::_a0;
            using b_t::_a1;
            using b_t::_h_res;
            using b_t::_h_a0;
            using b_t::_h_a1;
            using b_t::check_res;

            // coefficients for exp generated by sollya
            // x^0 : +0x8p-3
            static
            constexpr
            const double exp_c0=+1.0000000000000000000000e+00;
            // x^1 : +0x8p-3
            static
            constexpr
            const double exp_c1=+1.0000000000000000000000e+00;
            // x^2 : +0x8p-4
            static
            constexpr
            const double exp_c2=+5.0000000000000000000000e-01;
            // x^3 : +0xa.aaaaaaaaaaaa8p-6
            static
            constexpr
            const double exp_c3=+1.6666666666666665741481e-01;
            // x^4 : +0xa.aaaaaaaaaaacp-8
            static
            constexpr
            const double exp_c4=+4.1666666666666685170384e-02;
            // x^5 : +0x8.888888888961p-10
            static
            constexpr
            const double exp_c5=+8.3333333333340843529502e-03;
            // x^6 : +0xb.60b60b60a81p-13
            static
            constexpr
            const double exp_c6=+1.3888888888873365812238e-03;
            // x^7 : +0xd.00d00cfa88cc8p-16
            static
            constexpr
            const double exp_c7=+1.9841269839039331096715e-04;
            // x^8 : +0xd.00d00d6b5b978p-19
            static
            constexpr
            const double exp_c8=+2.4801587348902822885563e-05;
            // x^9 : +0xb.8ef1e87f81768p-22
            static
            constexpr
            const double exp_c9=+2.7557322326013774747291e-06;
            // x^10 : +0x9.3f26623e02258p-25
            static
            constexpr
            const double exp_c10=+2.7557252167692825528943e-07;
            // x^11 : +0xd.72da4d99dd1ep-29
            static
            constexpr
            const double exp_c11=+2.5050050656120229688701e-08;
            // x^12 : +0x8.fc5bcb2f9dd7p-32
            static
            constexpr
            const double exp_c12=+2.0921639307947297714762e-09;
            // x^13 : +0xb.675e3aadcbc88p-36
            static
            constexpr
            const double exp_c13=+1.6594686274338619941159e-10;
        
            static
            const float coeff4[4];

            static
            const float coeff5[5];

            static
            const float coeff6[6];

            static
            const float coeff7[7];

            static
            const float coeff8[8];

            static
            const float coeff9[9];

            static
            const float coeff10[10];

        public:
            horner_f32(size_t n)
                : b_t(n, float(-M_LN2/2), float(2*M_LN2/2)) {}
            bool perform();
        };
        
        const int VEC_SIZE=1;
        const int ELEMENTS=((4*1024*1024)/VEC_SIZE)-1;

        void
        test_add12cond(const dvec<float>& x);

        void
        test_mul12(const dvec<float>& x);

        void
        test_horner(const dvec<float>& x);


    }
    

};

const float
ocl::test::horner_f32::coeff4[4]= {
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff5[5]= {
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff6[6]= {
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff7[7]= {
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff8[8]= {
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff9[9]= {
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

const float
ocl::test::horner_f32::coeff10[10]= {
    exp_c9,
    exp_c8,
    exp_c7,
    exp_c6,
    exp_c5,
    exp_c4,
    exp_c3,
    exp_c2,
    exp_c1,
    exp_c0
};

bool
ocl::test::horner_f32::perform()
{
    using cftal::math::horner;
    using cftal::math::horner2;
    using cftal::math::horner4;
    bool rc=true;

    dvec<float> x2=_a0*_a0;
    dvec<float> x4=x2*x2;
    lvec<float> h_x2=_h_a0 * _h_a0;
    lvec<float> h_x4=h_x2 * h_x2;

    constexpr const auto max_rel_tol=0x1p-24f*2.0f; 
    // std::numeric_limits<float>::epsilon();
    
    _res = horner(_a0, coeff4);
    _h_res = horner(_h_a0, coeff4);
    rc &= check_res("horner(v, c[4])", max_rel_tol);

    _res = horner2(_a0, x2, coeff4);
    rc &= check_res("horner2(v, c[4])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff4);
    rc &= check_res("horner4(v, c[4])", 2*max_rel_tol);
    
    _res = horner(_a0, coeff5);
    _h_res = horner(_h_a0, coeff5);
    rc &= check_res("horner(v, c[5])", max_rel_tol);
    _res = horner2(_a0, x2, coeff5);
    rc &= check_res("horner2(v, c[5])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff5);
    rc &= check_res("horner4(v, c[5])", 2*max_rel_tol);

    _res = horner(_a0, coeff6);
    _h_res = horner(_h_a0, coeff6);
    rc &= check_res("horner(v, c[6])", max_rel_tol);
    _res = horner2(_a0, x2, coeff6);
    rc &= check_res("horner2(v, c[6])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff6);
    rc &= check_res("horner4(v, c[6])", 4*max_rel_tol);

    _res = horner(_a0, coeff7);
    _h_res = horner(_h_a0, coeff7);
    rc &= check_res("horner(v, c[7])", max_rel_tol);
    _res = horner2(_a0, x2, coeff7);
    rc &= check_res("horner2(v, c[7])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff7);
    rc &= check_res("horner4(v, c[7])", 4*max_rel_tol);

    _res = horner(_a0, coeff8);
    _h_res = horner(_h_a0, coeff8);
    rc &= check_res("horner(v, c[8])", max_rel_tol);
    _res = horner2(_a0, x2, coeff8);
    rc &= check_res("horner2(v, c[8])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff8);
    rc &= check_res("horner4(v, c[8])", 4*max_rel_tol);

    _res = horner(_a0, coeff9);
    _h_res = horner(_h_a0, coeff9);
    rc &= check_res("horner(v, c[9])", max_rel_tol);
    _res = horner2(_a0, x2, coeff9);
    rc &= check_res("horner2(v, c[9])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff9);
    rc &= check_res("horner4(v, c[9])", 4*max_rel_tol);

    _res = horner(_a0, coeff10);
    _h_res = horner(_h_a0, coeff10);
    rc &= check_res("horner(v, c[10])", max_rel_tol);
    _res = horner2(_a0, x2, coeff10);
    rc &= check_res("horner2(v, c[10])", 2*max_rel_tol);
    _res = horner4(_a0, x2, x4, coeff10);
    rc &= check_res("horner4(v, c[10])", 4*max_rel_tol);
    return rc;
}

void
ocl::test::test_add12cond(const dvec<float>& x)
{
    using vf_type = dvec<float>;

    vf_type a=x, b=x;
    using d_ops=cftal::d_real_ops<vf_type, false>;
    vf_type h, l;
    d_ops::add12cond(h, l, a, b);
    vf_type hh, ll;
    d_ops::add22cond(hh, ll, h, l, h, l);
    // std::cout << __PRETTY_FUNCTION__ << std::endl;
}

void
ocl::test::test_mul12(const dvec<float>& x)
{
    using vf_type = dvec<float>;
    vf_type a=x, b=x;
    using d_ops=cftal::d_real_ops<vf_type, false>;
    vf_type h, l;
    d_ops::mul12(h, l, a, b);
    vf_type hh, ll;
    d_ops::sqr22(hh, ll, h, l);
    d_ops::div22(hh, ll, hh, ll, h, l);
    // std::cout << __PRETTY_FUNCTION__ << std::endl;
    // std::dvec<float> hh(h), hl(l);
}

void
ocl::test::test_horner(const dvec<float>& x)
{
    using vf_type = dvec<float>;
    // using vi_type = dvec<int32_t>;
    constexpr
    const float log_c1=+1.0000000000000000000000e+00;
    // x^2 : -0x8p-4
    constexpr
    const float log_c2=-5.0000000000000000000000e-01;
    // x^3 : +0xa.aaaaaaaaaaac8p-5
    constexpr
    const float log_c3=+3.3333333333333353687422e-01;
    // x^4 : -0x8.0000000000208p-5
    constexpr
    const float log_c4=-2.5000000000000360822483e-01;
    // x^5 : +0xc.ccccccccc6e9p-6
    constexpr
    const float log_c5=+1.9999999999991630028617e-01;
    // x^6 : -0xa.aaaaaaaa58168p-6
    constexpr
    const float log_c6=-1.6666666666549315167778e-01;
    // x^7 : +0x9.24924927ac58p-6
    constexpr
    const float log_c7=+1.4285714286842710052383e-01;
    // x^8 : -0x8.00000027e75c8p-6
    constexpr
    const float log_c8=-1.2500000014516901569728e-01;
    // x^9 : +0xe.38e38cbfa4d38p-7
    constexpr
    const float log_c9=+1.1111111042490638689539e-01;
    // x^10 : -0xc.ccccb8d164208p-7
    constexpr
    const float log_c10=-9.9999990695125454132075e-02;
    // x^11 : +0xb.a2e8e4465066p-7
    constexpr
    const float log_c11=+9.0909110510099810920082e-02;
    // x^12 : -0xa.aaad942807438p-7
    constexpr
    const float log_c12=-8.3333680479023994336352e-02;
    // x^13 : +0x9.d89c440648528p-7
    constexpr
    const float log_c13=+7.6922925200565275827280e-02;
    // x^14 : -0x9.24504f5c6c73p-7
    constexpr
    const float log_c14=-7.1420706511023362983437e-02;
    // x^15 : +0x8.88565bbd4181p-7
    constexpr
    const float log_c15=+6.6660685343332942709438e-02;
    // x^16 : -0x8.0381a20dc6aap-7
    constexpr
    const float log_c16=-6.2607006194914049945766e-02;
    // x^17 : +0xf.1b610aa965e5p-8
    constexpr
    const float log_c17=+5.9011521437603756123913e-02;
    // x^18 : -0xe.04b526d45cb08p-8
    constexpr
    const float log_c18=-5.4759332637660980414029e-02;
    // x^19 : +0xc.e282859d9531p-8
    constexpr
    const float log_c19=+5.0331266041742109274004e-02;
    // x^20 : -0xd.55ffa43077a8p-8
    constexpr
    const float log_c20=-5.2093484483036633925224e-02;
    // x^21 : +0xf.7e2701c5769a8p-8
    constexpr
    const float log_c21=+6.0518682415443704469826e-02;
    // x^22 : -0xd.b9eebf859befp-8
    constexpr
    const float log_c22=-5.3618356474188763605149e-02;
    // x^23 : +0xb.508a0d3fd5d08p-9
    constexpr
    const float log_c23=+2.2098840825417579575296e-02;

    static_assert(log_c1 == 1.0, "constraint violated");
    static const float ci[]={
        log_c23, log_c22, log_c21, log_c20, log_c19,
        log_c18, log_c17, log_c16, log_c15, log_c14,
        log_c13, log_c12, log_c11, log_c10, log_c9,
        log_c8,  log_c7,  log_c6,  log_c5,  log_c4,
        log_c3,  log_c2,  log_c1
    };
    vf_type x2=x*x;
    vf_type x4=x*x*x*x;
    for (int i=0; i<4; ++i) {
#if 0
        vf_type y0=horner(x,
                          log_c23, log_c22, log_c21, log_c20, log_c19,
                          log_c18, log_c17, log_c16, log_c15, log_c14,
                          log_c13, log_c12, log_c11, log_c10, log_c9,
                          log_c8,  log_c7,  log_c6,  log_c5,  log_c4,
                          log_c3,  log_c2,  log_c1);
#endif
        vf_type y1=horner(x, ci);
        vf_type y2=horner2(x, x2, ci);
        vf_type y4=horner4(x, x2, x4, ci);
        // vi_type eq=y0 == y1;
        // vi_type eq0=y0 == 1.0f;
    }
    // std::cout << __PRETTY_FUNCTION__ << std::endl;
    // ocl::impl::be_data::instance()->q().finish();
}

int main()
{
    try {
        using namespace cftal;
        using namespace ocl;
        using namespace ocl::test;

        using rtype = float;
        // using itype = int64_t;
        // using v8fXX = cftal::vec<ftype, 8>;
        for (std::size_t i=4; i<16384; ++i) {
            if ((i & 0x7f) == 0x7f || i==1) {
                std::cout << "using buffers with "
                          <<  i
                          << " elements (" << i*sizeof(rtype)
                          << " bytes)\r" << std::flush;
            }
            horner_f32 t(i);
            if (t.perform() == false) {
                std::cout << "\ntest for vector length " << i << " failed\n";
                std::exit(3);
            }
        }
        std::cout << "\ntest passed\n";
    }
    catch (const ocl::be::error& e) {
        std::cout << "caught exception: " << e.what()
                  << '\n'
                  << e.error_string()
                  << std::endl;
    }
    catch (const std::runtime_error& e) {
        std::cout << "caught exception: " << e.what()
                  << std::endl;
    }
    return 0;
}

